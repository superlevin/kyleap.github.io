[{"title":"Elmah + Nlog 摻在一起做Exception Logs吧 - Elmah 部分","date":"2017-08-26T05:26:32.000Z","path":"2017/08/26/nlog-elmah-together/","text":"前言Elmah一看就知道是老江湖了，在前部落格也寫過文章，本次新系統套上時因要內部分享，所以再順便重新寫一篇整理到此Blog來。系統上線後，一定會遇到一些Bug，但如何在User抱怨之前，將Bug以最短時間內處理掉是很重要的是。Elmah能幫我們紀錄網站所發生的錯誤，並可以配上一些通知機制，來通知系統管理員查看。而系統一些自訂例外處理的Log我習慣使用Nlog，但如果能統一個Dashboard查看就太方便了，故預計以兩篇文章來紀錄個整合。 環境 ASP.NET Web API (.NET Freamwork 4.7) Elmah v1.1.2 Elmah.SqlServer (option) v1.2.0 步驟 安裝 Elmah 安裝 Elmah.SqlServer Web API 增加捕捉例外 其他實用調整 安裝 Elmah &amp; Elmah.SqlServer透過 Nuget 安裝 在 WebConfig 能看到下面這段，預設dashboard的route是elmah.axd，當然也可以在此config修改這個路徑。 123456789101112131415161718192021&lt;location path=\"elmah.axd\" inheritInChildApplications=\"false\"&gt; &lt;system.web&gt; &lt;httpHandlers&gt; &lt;add verb=\"POST,GET,HEAD\" path=\"elmah.axd\" type=\"Elmah.ErrorLogPageFactory, Elmah\" /&gt; &lt;/httpHandlers&gt; &lt;!-- See http://code.google.com/p/elmah/wiki/SecuringErrorLogPages for more information on using ASP.NET authorization securing ELMAH. &lt;authorization&gt; &lt;allow roles=\"admin\" /&gt; &lt;deny users=\"*\" /&gt; &lt;/authorization&gt; --&gt; &lt;/system.web&gt; &lt;system.webServer&gt; &lt;handlers&gt; &lt;add name=\"ELMAH\" verb=\"POST,GET,HEAD\" path=\"elmah.axd\" type=\"Elmah.ErrorLogPageFactory, Elmah\" preCondition=\"integratedMode\" /&gt; &lt;/handlers&gt; &lt;/system.webServer&gt; &lt;/location&gt; 直接執行第一個404錯誤，接著連到 http://localhost:xxxx/elmah.axd 就能捕捉到第一個例外，按 Detail 還能看到更多完整錯誤訊息。 而如果想要把Log記錄到SQL Server，可以按照以下步驟 安裝完後可以看到App_Readme多了SQL Table建立的Script 將此Script丟到你的資料庫執行，完成建立以下Table 修改 WebConfig 的 connection string 1234&lt;connectionStrings&gt; &lt;!-- TODO: Replace the ****'s with the correct entries --&gt; &lt;add name=\"elmah-sqlserver\" connectionString=\"Data Source=****;User ID=****;Password=****;Initial Catalog=****;\" providerName=\"System.Data.SqlClient\" /&gt;&lt;/connectionStrings&gt; 再模擬一次 404 錯誤，確認錯誤訊息能寫入 SQL Server Web API 如何擷取例外保哥已經有很清楚的一篇了 :) :) 延伸閱讀:如何在 ASP.NET Web API 套用 ELMAH 錯誤紀錄模組 實務上我也會在 ExceptionFilterAttribute 作統一的錯誤格式回傳處理 Elmah 其他必要小提醒 如何在Code直接寫入Elmah?只要利用 ErrorSignal 即可在程式裡捕捉例外 12345678try&#123; throw new Exception(\"發生錯誤!\");&#125;catch (Exception e)&#123; ErrorSignal.FromCurrentContext().Raise(e);&#125; 如何管控 Dashboard 權限?只要取消 WebConfig Elmah Location 註解 ，改成系統自定義的角色1234&lt;authorization&gt; &lt;allow roles=\"admin\" /&gt; &lt;deny users=\"*\" /&gt; &lt;/authorization&gt; 如何錯誤發生時發送Mail通知?在 WebConfig 設定 SMTP1234567&lt;system.net&gt; &lt;mailSettings&gt; &lt;smtp deliveryMethod =\"Network\"&gt; &lt;network host=\"smtp.gmail.com\" port=\"587\" userName=\"xxxxx@gmail\" password=\"xxxxxx\" /&gt; &lt;/smtp&gt; &lt;/mailSettings&gt;&lt;/system.net&gt; 在 webConfg Elmah 區塊增加 errorMail，設定相關通知對象12&lt;errorMail from=\"xxxxx@gmail.com\" to=\"xxxxxx@gmail.com\" async=\"true\" smtpPort=\"0\" useSsl=\"true\" /&gt; E-mail 很吵，能整合其他通訊軟體嗎?延伸閱讀：http://demo.tc/post/817 在 Web API 例外發生的時候通知 Slack 照demo哥的文章，應該能申請到一個Web Hook URL，只要在上面提到的 ExceptionFilterAttribute 實作就好了，我通常會用一個介面來實作各個通知機制，內容通常是引導到 Elmah Dashboard，logBoardUrl這個變數會針對不同的site去寫入URL1NotifyService.Error($\"Unexpected Error From `API`, Error Logs : &lt;&#123;logBoardUrl&#125;&gt;\"); (Slack Payload Format可以有很多玩法 可以有很多應用喔，譬如能加Button，自己做處理流程 :) )https://api.slack.com/docs/message-formatting 以下簡單用 WebClinet發送的範例12345678910111213141516171819202122public class SlackService : INotificationService&#123; public void Error(string message) &#123; var hook = ConfigurationManager.AppSettings[\"SlackErrorHook\"]; var serverName = ConfigurationManager.AppSettings[\"ServerName\"]; var payload = new &#123; text = message, icon_emoji = \":what:\", // 自訂不要那麼焦慮的ICON username = \"黑人問號Bot \" + serverName &#125;; using (WebClient client = new WebClient()) &#123; NameValueCollection slack_payload = new NameValueCollection(); slack_payload[\"payload\"] = JsonConvert.SerializeObject(payload); var _uri = hook; var response = client.UploadValues(_uri, \"POST\", slack_payload); &#125; &#125;&#125; 後記寫到這裡突然發現篇幅過長，Nlog留到下一篇吧 Q_Q","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"//litten.me/tags/ASP-NET/"},{"name":"Elmah","slug":"Elmah","permalink":"//litten.me/tags/Elmah/"}]},{"title":"在ASP.NET利用Hangfire搭配SQL Server來管理排程作業","date":"2017-07-24T16:34:28.000Z","path":"2017/07/25/hangfire-sql-server/","text":"前言在以往寫.NET排程需求時，我通常會用Console Application 搭配 Windows Server的排程器來做設定，最近嘗試在專案使用 hangfire 來做管理，hangfire 是一套open source的Freamwork，它能很容易的管理背景作業，並且有 Dashboard 介面來查看作業狀態及執行，本篇文章將以ASP.NET專案搭配SQL Server做個安裝筆記。 Nuget 安裝套件 Hangfire.core https://www.nuget.org/packages/Hangfire.Core/ Hangfire.SqlServer https://www.nuget.org/packages/Hangfire.SqlServer/ Create DB Schema 存Jobs的資料在方案nuget package裡的Hangfire.SqlServer資料夾，應會有所需Table的Script 執行安裝後應該會有底下這些 Table 專案設定在ASP.NET專案的 Startup.cs 檔案引入hangfire 123456789101112131415161718public void Configuration(IAppBuilder app)&#123; GlobalConfiguration.Configuration.UseSqlServerStorage ( \"hangfire-sqlserver\", new SqlServerStorageOptions &#123; // if it is set to 1 minutes, each worker will run a keep-alive query each minute when processing a job QueuePollInterval = TimeSpan.FromMinutes(1) &#125; ); // 啟用HanfireServer app.UseHangfireServer(new BackgroundJobServerOptions &#123; WorkerCount = 1 &#125;); RecurringJob.AddOrUpdate&lt;SendMessageAlert&gt;(\"SendMessageAlert\", x =&gt; x.SendMessage(), Cron.MinuteInterval(1), TimeZoneInfo.FindSystemTimeZoneById(\"Taipei Standard Time\"));&#125; SendMessageAlert 是一個自己建立的類別，可以將排程實際的所需的實作寫在裡面，譬如實務上很常發送排程E-mail通知信件，而以此例我們設定排程頻率為1分鐘執行一次，視實際情況可以調整為 Daily Hourly Monthly Weekly Yearly 12345678public class SendMessageAlert&#123; public void SendMessage() &#123; // TODO:發送排程信件 Console.WriteLine(DateTime.Now); &#125;&#125; 到此步驟可以執行看看，每分鐘應該會進入SendMessage Method 加入 Dashboard回到 Startup.cs，只要加入以下程式即可開啟Dashboard功能 12345// 開啟Hangfire的Dashboardapp.UseHangfireDashboard(\"/hangfire\", new DashboardOptions&#123; Authorization = new[] &#123; new HangfireAuthorizationFilter() &#125;&#125;); 當然這個Dashboard我們不希望能讓任何人能存取，所以能自訂一個 HangfireAuthorizationFilter 來驗證是否有存取權限 123456789101112131415public class HangfireAuthorizationFilter : IDashboardAuthorizationFilter&#123; public bool Authorize([NotNull] DashboardContext context) &#123; // 是否允許存取hangfire Dashboard if (HttpContext.Current.User.IsInRole(\"Admin\")) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 結果圖數據分析 排程紀錄，也可手動執行 參考連結 http://blog.kkbruce.net/2015/09/hangfire-aspnet-mvc-webapi.html#.WXYg84iGOUk https://dotblogs.com.tw/rainmaker/2015/08/19/153169","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"//litten.me/tags/ASP-NET/"},{"name":"HangFire","slug":"HangFire","permalink":"//litten.me/tags/HangFire/"}]},{"title":"Github Page Hello World","date":"2017-07-23T10:25:59.012Z","path":"2017/07/23/my-first-helloworld/","text":"聽說任何第一個專案不寫 Hello Wold會出事的，所以此篇就當個開頭吧 :)我的舊Blog連結: http://kyleap.blogspot.tw/ 123console.log('Hello World !!');console.log('Hello World !!');console.log('Hello World !!');","tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"//litten.me/tags/碎碎念/"}]}]